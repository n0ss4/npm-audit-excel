import { AuditReport, ProcessedVulnerability, Vulnerability, VulnerabilityDetail } from '../types';

export class VulnerabilityProcessor {
  private readonly severityWeights = {
    critical: 40,
    high: 30,
    moderate: 20,
    low: 10,
    info: 5
  };

  processAuditReport(auditData: AuditReport): ProcessedVulnerability[] {
    const vulnerabilities: ProcessedVulnerability[] = [];

    for (const [packageName, vulnInfo] of Object.entries(auditData.vulnerabilities)) {
      const processed = this.processVulnerability(packageName, vulnInfo);
      vulnerabilities.push(processed);
    }

    // Sort by priority score (descending) and then by severity
    return vulnerabilities.sort((a, b) => {
      if (b.priorityScore !== a.priorityScore) {
        return b.priorityScore - a.priorityScore;
      }
      return this.getSeverityOrder(a.severity) - this.getSeverityOrder(b.severity);
    });
  }

  private processVulnerability(packageName: string, vulnInfo: Vulnerability): ProcessedVulnerability {
    const baseInfo: ProcessedVulnerability = {
      package: packageName,
      severity: vulnInfo.severity,
      isDirect: vulnInfo.isDirect,
      range: vulnInfo.range,
      fixAvailable: false,
      fixVersion: 'N/A',
      fixPackage: packageName,
      isSemVerMajor: false,
      effectsCount: vulnInfo.effects?.length || 0,
      viaCount: vulnInfo.via?.length || 0,
      cvssScore: 0,
      vulnerabilityTitle: 'Multiple vulnerabilities',
      advisoryUrl: 'N/A',
      cwe: 'N/A',
      fixCommand: '',
      priorityScore: 0,
      priorityCategory: 'LOW'
    };

    // Process fix information
    if (vulnInfo.fixAvailable) {
      baseInfo.fixAvailable = true;
      if (typeof vulnInfo.fixAvailable === 'object') {
        baseInfo.fixVersion = vulnInfo.fixAvailable.version || 'N/A';
        baseInfo.fixPackage = vulnInfo.fixAvailable.name || packageName;
        baseInfo.isSemVerMajor = vulnInfo.fixAvailable.isSemVerMajor || false;
      }
    }

    // Process vulnerability details
    const viaDetails = this.extractViaDetails(vulnInfo.via);
    if (viaDetails.length > 0) {
      baseInfo.cvssScore = Math.max(...viaDetails.map(d => d.cvssScore));
      baseInfo.vulnerabilityTitle = viaDetails[0].title;
      baseInfo.advisoryUrl = viaDetails[0].url;
      baseInfo.cwe = viaDetails[0].cwe;
    }

    // Generate fix command
    baseInfo.fixCommand = this.generateFixCommand(baseInfo);

    // Calculate priority
    baseInfo.priorityScore = this.calculatePriorityScore(baseInfo);
    baseInfo.priorityCategory = this.categorizePriority(baseInfo.priorityScore);

    return baseInfo;
  }

  private extractViaDetails(via: Array<string | VulnerabilityDetail>): Array<{
    title: string;
    url: string;
    cwe: string;
    cvssScore: number;
  }> {
    const details: Array<{
      title: string;
      url: string;
      cwe: string;
      cvssScore: number;
    }> = [];

    for (const viaItem of via || []) {
      if (typeof viaItem === 'object' && 'title' in viaItem) {
        details.push({
          title: viaItem.title || 'N/A',
          url: viaItem.url || 'N/A',
          cwe: viaItem.cwe?.join(', ') || 'N/A',
          cvssScore: viaItem.cvss?.score || 0
        });
      }
    }

    return details;
  }

  private generateFixCommand(vuln: ProcessedVulnerability): string {
    if (!vuln.fixAvailable) {
      return 'No fix available';
    }

    if (vuln.isDirect) {
      if (vuln.isSemVerMajor) {
        return `npm install ${vuln.fixPackage}@${vuln.fixVersion} --save`;
      }
      return `npm update ${vuln.fixPackage}`;
    }

    return 'npm audit fix --force';
  }

  private calculatePriorityScore(vuln: ProcessedVulnerability): number {
    let score = 0;

    // Base score from severity
    const severity = vuln.severity as keyof typeof this.severityWeights;
    score += this.severityWeights[severity] || 0;

    // Bonus for direct dependencies
    if (vuln.isDirect) {
      score += 15;
    }

    // Bonus for available fix
    if (vuln.fixAvailable) {
      score += 10;
    }

    // Penalty for complex dependencies
    score -= Math.min(vuln.effectsCount * 2, 10);

    // Bonus for high CVSS scores
    if (vuln.cvssScore >= 9) {
      score += 10;
    } else if (vuln.cvssScore >= 7) {
      score += 5;
    }

    // Penalty for major version changes
    if (vuln.isSemVerMajor) {
      score -= 5;
    }

    return Math.max(score, 0);
  }

  private categorizePriority(score: number): 'URGENT' | 'HIGH' | 'MEDIUM' | 'LOW' {
    if (score >= 50) return 'URGENT';
    if (score > 35) return 'HIGH';
    if (score >= 20) return 'MEDIUM';
    return 'LOW';
  }

  private getSeverityOrder(severity: string): number {
    const order = {
      critical: 0,
      high: 1,
      moderate: 2,
      low: 3,
      info: 4
    };
    return order[severity as keyof typeof order] || 5;
  }
}
