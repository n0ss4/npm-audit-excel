import type { ReportConfig } from '../config';
import { NPM_COMMANDS } from '../config/constants';
import type {
  AuditReport,
  ProcessedVulnerability,
  Vulnerability,
  VulnerabilityDetail,
} from '../types';

export class VulnerabilityProcessor {
  private config: ReportConfig;

  constructor(config: ReportConfig) {
    this.config = config;
  }

  processAuditReport(auditData: AuditReport): ProcessedVulnerability[] {
    const vulnerabilities: ProcessedVulnerability[] = [];

    for (const [packageName, vulnInfo] of Object.entries(auditData.vulnerabilities)) {
      const processed = this.processVulnerability(packageName, vulnInfo);
      vulnerabilities.push(processed);
    }

    return vulnerabilities.sort((a, b) => {
      if (b.priorityScore !== a.priorityScore) {
        return b.priorityScore - a.priorityScore;
      }
      return this.getSeverityOrder(a.severity) - this.getSeverityOrder(b.severity);
    });
  }

  private processVulnerability(
    packageName: string,
    vulnInfo: Vulnerability
  ): ProcessedVulnerability {
    const baseInfo: ProcessedVulnerability = {
      package: packageName,
      severity: vulnInfo.severity,
      isDirect: vulnInfo.isDirect,
      range: vulnInfo.range,
      fixAvailable: false,
      fixVersion: 'N/A',
      fixPackage: packageName,
      isSemVerMajor: false,
      effectsCount: vulnInfo.effects?.length || 0,
      viaCount: vulnInfo.via?.length || 0,
      cvssScore: 0,
      vulnerabilityTitle: 'Multiple vulnerabilities',
      advisoryUrl: 'N/A',
      cwe: 'N/A',
      fixCommand: '',
      priorityScore: 0,
      priorityCategory: 'LOW',
    };

    if (vulnInfo.fixAvailable) {
      baseInfo.fixAvailable = true;
      if (typeof vulnInfo.fixAvailable === 'object') {
        baseInfo.fixVersion = vulnInfo.fixAvailable.version || 'N/A';
        baseInfo.fixPackage = vulnInfo.fixAvailable.name || packageName;
        baseInfo.isSemVerMajor = vulnInfo.fixAvailable.isSemVerMajor || false;
      }
    }

    const viaDetails = this.extractViaDetails(vulnInfo.via);
    if (viaDetails.length > 0) {
      baseInfo.cvssScore = Math.max(...viaDetails.map(d => d.cvssScore));
      baseInfo.vulnerabilityTitle = viaDetails[0].title;
      baseInfo.advisoryUrl = viaDetails[0].url;
      baseInfo.cwe = viaDetails[0].cwe;
    }

    baseInfo.fixCommand = this.generateFixCommand(baseInfo);

    baseInfo.priorityScore = this.calculatePriorityScore(baseInfo);
    baseInfo.priorityCategory = this.categorizePriority(baseInfo.priorityScore);

    return baseInfo;
  }

  private extractViaDetails(via: ReadonlyArray<string | VulnerabilityDetail>): Array<{
    title: string;
    url: string;
    cwe: string;
    cvssScore: number;
  }> {
    const details: Array<{
      title: string;
      url: string;
      cwe: string;
      cvssScore: number;
    }> = [];

    for (const viaItem of via || []) {
      if (typeof viaItem === 'object' && 'title' in viaItem) {
        details.push({
          title: viaItem.title || 'N/A',
          url: viaItem.url || 'N/A',
          cwe: viaItem.cwe?.join(', ') || 'N/A',
          cvssScore: viaItem.cvss?.score || 0,
        });
      }
    }

    return details;
  }

  private generateFixCommand(vuln: ProcessedVulnerability): string {
    if (!vuln.fixAvailable) {
      return NPM_COMMANDS.NO_FIX;
    }

    if (vuln.isDirect) {
      if (vuln.isSemVerMajor) {
        return NPM_COMMANDS.INSTALL_SPECIFIC(vuln.fixPackage, vuln.fixVersion);
      }
      return NPM_COMMANDS.UPDATE(vuln.fixPackage);
    }

    return NPM_COMMANDS.AUDIT_FIX_FORCE;
  }

  private calculatePriorityScore(vuln: ProcessedVulnerability): number {
    let score = 0;
    const scoring = this.config.scoring;

    const severity = vuln.severity as keyof typeof scoring.severityWeights;
    score += scoring.severityWeights[severity] || 0;

    if (vuln.isDirect) {
      score += scoring.bonusPoints.directDependency;
    }

    if (vuln.fixAvailable) {
      score += scoring.bonusPoints.fixAvailable;
    }

    score -= Math.min(
      vuln.effectsCount * scoring.penalties.effectsPerPackage,
      scoring.penalties.maxEffectsPenalty
    );

    if (vuln.cvssScore >= scoring.thresholds.highCvss) {
      score += scoring.bonusPoints.highCvss;
    } else if (vuln.cvssScore >= scoring.thresholds.mediumCvss) {
      score += scoring.bonusPoints.mediumCvss;
    }

    if (vuln.isSemVerMajor) {
      score -= scoring.penalties.majorVersion;
    }

    return Math.max(score, 0);
  }

  private categorizePriority(score: number): 'URGENT' | 'HIGH' | 'MEDIUM' | 'LOW' {
    const thresholds = this.config.scoring.thresholds;
    if (score >= thresholds.urgentPriority) return 'URGENT';
    if (score > thresholds.highPriority) return 'HIGH';
    if (score >= thresholds.mediumPriority) return 'MEDIUM';
    return 'LOW';
  }

  private getSeverityOrder(severity: string): number {
    const order = {
      critical: 0,
      high: 1,
      moderate: 2,
      low: 3,
      info: 4,
    };
    return order[severity as keyof typeof order] || 5;
  }
}
